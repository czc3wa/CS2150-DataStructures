\href{../index.html}{\tt Go up to the Labs table of contents page}

\subsubsection*{Objective}

To become familiar with representing directed acyclic graphs (D\+A\+Gs), topological sorting, and the traveling salesperson problem.

\subsubsection*{Background}

A graph is a set of vertices connected by edges. In a directed graph, an edge is an ordered pair of vertices, where you can follow an edge from one vertex to another. In a directed acyclic graph (D\+AG), no path starts and ends at the same vertex. A topological sort orders the vertices in a D\+AG such that any edge from vertex i to vertex j satisfies i $<$ j.

\subsubsection*{Reading(s)}


\begin{DoxyEnumerate}
\item The \href{http://en.wikipedia.org/wiki/Topological_sort}{\tt Wikipedia page on Topological sort}
\item The \href{http://en.wikipedia.org/wiki/Travelling_salesman_problem}{\tt Wikipedia page on the Traveling Salesperson problem}
\item \href{../../slides/11-graphs.html}{\tt The slides on graphs}
\end{DoxyEnumerate}

\subsection*{Procedure }

\subsubsection*{Pre-\/lab}


\begin{DoxyEnumerate}
\item Go through the \href{../../tutorials/11-doxygen/index.html}{\tt Doxygen tutorial}, as described in the pre-\/lab section.
\item Study the topological sort algorithm described in the readings
\item Look at the \href{middleearth.h.html}{\tt middleearth.\+h} (\href{middleearth.h}{\tt src}) and \href{middleearth.cpp.html}{\tt middleearth.\+cpp} (\href{middleearth.cpp}{\tt src}) files. You should understand {\bfseries A\+ND D\+O\+C\+U\+M\+E\+NT} both of these two files. See the comments in the middleearth.\+cpp file, as well as the in-\/lab section, for details as to what these methods do. You should not modify any of the code in this file; only the comments.
\begin{DoxyItemize}
\item You will have to create a Doxyfile, as described in the \href{../../tutorials/11-doxygen/index.html}{\tt Doxygen tutorial}
\item That Doxyfile should {\itshape only} generate H\+T\+ML output (thus, set {\ttfamily G\+E\+N\+E\+R\+A\+T\+E\+\_\+\+L\+A\+T\+EX} and {\ttfamily G\+E\+N\+E\+R\+A\+T\+E\+\_\+\+R\+TF} to \char`\"{}\+N\+O\char`\"{})
\item That Doxyfile {\itshape should} generate graphs (thus, set {\ttfamily H\+A\+V\+E\+\_\+\+D\+OT}, {\ttfamily C\+A\+L\+L\+\_\+\+G\+R\+A\+PH}, and {\ttfamily C\+A\+L\+L\+E\+R\+\_\+\+G\+R\+A\+PH} all to \char`\"{}\+Y\+E\+S\char`\"{})
\item Be sure to change the other options of the Doxyfile as described in the tutorial (don\textquotesingle{}t forget {\ttfamily I\+N\+P\+UT} and {\ttfamily E\+X\+T\+R\+A\+C\+T\+\_\+\+A\+LL}!)
\item Your {\ttfamily I\+N\+P\+UT} tag should include the two middleearth files, as well as the topological sort files
\end{DoxyItemize}
\item Write a program to compute a topological sort of a graph, as described in the pre-\/lab section; name it {\ttfamily topological.\+cpp}.
\item Document your topological.\+cpp with doxygen commands.
\item Your code should compile with {\ttfamily make}! It should do $\ast$$\ast$$\ast$\+T\+W\+O$\ast$$\ast$$\ast$ tasks\+: compile your code, and call {\ttfamily doxygen}. See the pre-\/lab section for more information about required make target.
\item Files to download\+: \href{prelab-test-full.txt}{\tt prelab-\/test-\/full.\+txt}, \href{prelab-test-small.txt}{\tt prelab-\/test-\/small.\+txt}, \href{middleearth.h.html}{\tt middleearth.\+h} (\href{middleearth.h}{\tt src}), \href{middleearth.cpp.html}{\tt middleearth.\+cpp} (\href{middleearth.cpp}{\tt src}), \href{fileio2.cpp.html}{\tt fileio2.\+cpp} (\href{fileio2.cpp}{\tt src})
\item Files to submit\+: topological.\+cpp, \hyperlink{middleearth_8h_source}{middleearth.\+h}/cpp, Makefile, Doxyfile
\end{DoxyEnumerate}

\subsubsection*{In-\/lab}


\begin{DoxyEnumerate}
\item Implement a brute-\/force traveling salesperson solution, as described in the in-\/lab section.
\item Create a Makefile that will fully compile your code. You should not specify the resulting executable name (i.\+e., no {\ttfamily -\/o} output for the final link step). It will default to a.\+out, which is what is desired.
\item Document your C++ files with doxygen commands. You must {\bfseries A\+L\+SO} include commented \hyperlink{middleearth_8h_source}{middleearth.\+h} and middleearth.\+cpp (this should have been done in the pre-\/lab).
\item Your code should compile with {\ttfamily make}! It should do $\ast$$\ast$$\ast$\+T\+W\+O$\ast$$\ast$$\ast$ tasks\+: compile your code, and call {\ttfamily doxygen}. See the pre-\/lab section for more information about required make target.
\item Files to download\+: \href{traveling-skeleton.cpp.html}{\tt traveling-\/skeleton.\+cpp} (\href{traveling-skeleton.cpp}{\tt src}) (which you\textquotesingle{}ll have to rename to traveling.\+cpp), and your commented \hyperlink{middleearth_8h_source}{middleearth.\+h} / middleearth.\+cpp code from the pre-\/lab
\item Files to submit\+: traveling.\+cpp, \hyperlink{middleearth_8h_source}{middleearth.\+h}, middleearth.\+cpp, Makefile, Doxyfile
\end{DoxyEnumerate}

\subsubsection*{Post-\/lab}


\begin{DoxyEnumerate}
\item Complete the post-\/lab report, as described in the post-\/lab section.
\item Files to download\+: none (other than your pre-\/lab and in-\/lab files)
\item Files to submit\+: postlab11.\+pdf 


\end{DoxyEnumerate}

\subsection*{Pre-\/lab }

\subsubsection*{Doxygen tutorial}

First, read through the \href{../../tutorials/11-doxygen/index.html}{\tt Doxygen tutorial}. That tutorial then directs you to look though the doxygen manual, which you can \href{http://www.stack.nl/~dimitri/doxygen/download.html#dlmanual}{\tt download in P\+DF form} (you have to extract the P\+DF file) or \href{http://www.stack.nl/~dimitri/doxygen/manual/index.html}{\tt browse it online} (which is easier to view). Start with the \href{http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html}{\tt \char`\"{}\+Documenting the code\char`\"{} chapter}, as the previous chapters are covered in the tutorial.

For all the code deliverables in this lab, you will need to document all of your code $\ast$$\ast$$\ast$as well as the code that we provide$\ast$$\ast$$\ast$ using doxygen. You will also need to create and submit a Doxyfile that properly generates the documentation. We are not expecting you to have read through the entire user manual. {\bfseries But we are expecting you to document your code beyond the example provided. Just putting in those tags is not what we are looking for.} Thus, you should read some of the user manual to get an idea of what you can do with Doxygen, and you should do some of these things in your code.

As described above, the changes to the default Doxyfile that must be made include, {\itshape but are not limited to}\+:


\begin{DoxyItemize}
\item You will have to create a Doxyfile, as described in the \href{../../tutorials/11-doxygen/index.html}{\tt Doxygen tutorial}
\item That Doxyfile should {\itshape only} generate H\+T\+ML output (thus, set {\ttfamily G\+E\+N\+E\+R\+A\+T\+E\+\_\+\+L\+A\+T\+EX} and {\ttfamily G\+E\+N\+E\+R\+A\+T\+E\+\_\+\+R\+TF} to \char`\"{}\+N\+O\char`\"{})
\item That Doxyfile {\itshape should} generate graphs (thus, set {\ttfamily H\+A\+V\+E\+\_\+\+D\+OT}, {\ttfamily C\+A\+L\+L\+\_\+\+G\+R\+A\+PH}, and {\ttfamily C\+A\+L\+L\+E\+R\+\_\+\+G\+R\+A\+PH} all to \char`\"{}\+Y\+E\+S\char`\"{})
\item Be sure to change the other options of the Doxyfile as described in the tutorial (don\textquotesingle{}t forget {\ttfamily I\+N\+P\+UT} and {\ttfamily E\+X\+T\+R\+A\+C\+T\+\_\+\+A\+LL}!)
\item Your {\ttfamily I\+N\+P\+UT} tag should include the two middleearth files, as well as the topological sort files
\end{DoxyItemize}

See the full \href{../../tutorials/11-doxygen/index.html}{\tt Doxygen tutorial} for the other options to set. You should not have to set any options in the Doxyfile that are not described in the tutorial.

\subsubsection*{Topological sort}

Recall from lecture that given a graph {\itshape G} = ({\itshape V},{\itshape E}), a topological sort of a directed acyclic graph is a linear listing of the vertices such that, for all pairs of vertices {\itshape v},{\itshape w} {$\in$} {\itshape V}, {\itshape v} is listed before {\itshape w} in the topological sort if ({\itshape v},{\itshape w}) {$\in$} {\itshape E} (i.\+e. if there is an edge from {\itshape v} to {\itshape w} in the graph, then {\itshape v} must be listed before {\itshape w} in the topological sort). This implies that if there is a {\itshape path} from {\itshape v} to {\itshape w} (not just an edge), then {\itshape v} must still list before {\itshape w} in the topological sort.

For the programming part of this lab, you will need to write a program that can perform a topological sort. This problem is specified in the next section. The specification is similar to that found in the \href{http://acmicpc.org}{\tt International Collegiate Programming Contests} -- a problem description, followed by a detailed explanation of the input and the output.

How you represent your graph is up to you -- choices include\+: node-\/with-\/pointers, adjacency list, adjacency matrix, and others. Just keep in mind that you will have to do a topological sort on this graph. The program must read in a list of directed edges from a file and (internally) generate the graph from it.

You don\textquotesingle{}t need to print out the graph. The algorithm for a topological sort can be found in the slides and lecture recordings, as well as in the readings.

Your program must be {\itshape completely contained} in a single file named topological.\+cpp, and must take in the input file name as a single command-\/line parameter. There is no limit (other than the memory size) to the number of nodes that we may provide (i.\+e. it could be very large, not just 7, as in the example here).

To read in strings from a file in the C++ manner, see the \href{fileio2.cpp.html}{\tt fileio2.\+cpp} (\href{fileio2.cpp}{\tt src}) file.

To test your code with a larger input, see the prelab-\/test-\/full.\+txt file; the prelab-\/test-\/small.\+txt is what is described in the problem below.

\subsubsection*{Makefile}

The first target in your Makefile can be named anything you want, but should do {\bfseries two} things\+: compile your code, and run doxygen. You can have two tabbed lines after the target specifier, which is the easiest way to accomplish this. In other words, we are just going to call {\ttfamily make}, and we want it to both compile your code and create your doxygen documentation. You are welcome to have additional targets, such as {\ttfamily clean}, if you would like. The in-\/lab Makefile should have the same dual-\/purpose target. 



\subsection*{Pre-\/lab Problem\+: Topological Sort }

It turns out that one of our teaching assistants did not take all of the pre-\/requisite computer science courses! That TA is all ready to graduate, but it turns that CS 1110 was never taken. The department came down hard, and decided to make that TA take all of the courses over again, to have the proper pre-\/requisite classes completed for each successive class. But the TA just got a job at Microsoft, and can only take one course a semester while working full time. In what order should the teaching assistant take the list of required courses to properly fulfill the pre-\/requisites this time around?

Given the following course pre-\/requisite graph\+:



There are multiple valid orders that the courses can be taken in; each is a valid topological sorts\+:


\begin{DoxyItemize}
\item cs1110 cs2110 cs2102 cs3330 cs2150 cs4414
\item cs1110 cs2110 cs2102 cs2150 cs3330 cs4414
\item cs1110 cs2102 cs2110 cs3330 cs2150 cs4414
\item cs1110 cs2102 cs2110 cs2150 cs3330 cs4414
\item cs1110 cs2110 cs3330 cs2102 cs2150 cs4414
\end{DoxyItemize}

Any one of these topological sorts is sufficient.

\subsubsection*{Input}

The program will take a single command-\/line parameter. This parameter will specify the file name that contains the input.

The input file will consist of a series of lines that each designate a directed edge. Each line will have two vertex names, separated by a single space; the edge is directed from the first to the second listed vertex name on a given line. Every vertex name is a series of alphanumeric characters only (a-\/z, A-\/Z, 0-\/9) without any spaces or punctuation. Note that case is relevant, so vertex {\ttfamily abc} is distinct from vertex {\ttfamily A\+BC}. The edges can be listed in any order.

The end of the input file is signified by two 0\textquotesingle{}s on the same line, separated by a single space.

You can assume that the provided graph is a directed acyclic graph, that it is weakly connected, and thus that there is at least one valid topological sort. You can further assume that there will not be more than 100 vertices in the graph.

\subsubsection*{Output}

The output is a valid topological sort of the vertices, each separated by one space, and all on one line. If there are multiple topological sorts, then any valid one is acceptable. No additional output!

\subsubsection*{Example}

Given the input file\+:


\begin{DoxyCode}
cs2110 cs2150
cs2102 cs2150
cs1110 cs2110
cs3330 cs4414
cs2150 cs4414
cs2110 cs3330
cs1110 cs2102
0 0
\end{DoxyCode}


A valid topological sort would be


\begin{DoxyCode}
cs1110 cs2110 cs2102 cs3330 cs2150 cs4414
\end{DoxyCode}
 



\subsection*{In-\/lab }

\subsubsection*{Introduction}

You are going to implement a program that will find a solution to the traveling salesperson problem. This problem is known to be \href{http://en.wikipedia.org/wiki/Np-complete}{\tt N\+P-\/complete}, which means that there is no known efficient solution to the problem, and it is believed that an efficient solution does not exist. Thus, we will be implementing a rather inefficient solution -- a brute-\/force method that tries every possible path combination.

The traveling salesperson problem is as described in lecture. In brief, you start from a given city (your \char`\"{}home\char`\"{} city), and have to travel to a number of other cities before returning home. There is a fixed cost between any two cities (miles traveled, dollars spent, time taken, etc.). The goal of this algorithm is to find the path that travels to each of the cities, in any order, and that has the minimum cost. Note that it is really a cycle, as you have to start and end in the same city. Also note that the direction you travel in the cycle does not matter, as the distance is the same.

If you want more background on the Traveling Salesperson problem, you can see \href{http://www-e.uni-magdeburg.de/mertens/TSP/TSP.html}{\tt here}.

The world we have chosen is \href{http://en.wikipedia.org/wiki/Middle-earth}{\tt Middle-\/\+Earth}, the location of J.\+R.\+R. Tolkien\textquotesingle{}s Hobbit and Lord of the Rings books and movies. The \hyperlink{middleearth_8h_source}{middleearth.\+h} and middleearth.\+cpp files, that you commented in the pre-\/lab, contain a class that will create a random 2-\/dimensional world. The \char`\"{}randomness\char`\"{} means that it will pick a given number of cities (or places), and randomly place them in the \char`\"{}world\char`\"{}. You can travel from any city to any other city, for a given cost (the distance). The city names are all from the books and movies, and can be seen at the beginning of the middleearth.\+cpp file -- there is a textual description in the code as to what all the places are. The randomness of the world means that cities that are nowhere near each other in the books/movies might be right next to each other in the random world.

When your program is completed, you will need to specify five command-\/line parameters to execute the traveling salesperson problem. The parameters are, in order\+:


\begin{DoxyEnumerate}
\item The x-\/size (i.\+e. width) of the world. We\textquotesingle{}ll use 20 throughout this lab.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item The y-\/size (i.\+e. height) of the world. We\textquotesingle{}ll use 20 throughout this lab.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item The number of cities in the world. There are currently 40 names specified at the top of middleearth.\+cpp, so you can\textquotesingle{}t specify more than 40 cities.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item The random seed. If you specify a given number, the same world will be created each time -- we\textquotesingle{}ll use this, below, when we talk about debugging. Supplying -\/1 will create a different random world each time the program is run.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item The number of cities to visit, other than the \char`\"{}home\char`\"{} city -- this can be as low as 1.
\end{DoxyEnumerate}

The skeleton code provided (\href{traveling-skeleton.cpp.html}{\tt traveling-\/skeleton.\+cpp} (\href{traveling-skeleton.cpp}{\tt src})) already parses the command-\/line parameters properly.

\subsubsection*{S\+TL Helper Functions}

There are a number of S\+TL functions that will help you in writing this program. All of these algorithms (and more!) are provided in the {\ttfamily $<$algorithms$>$} header file. This file is already included by traveling-\/skeleton.\+cpp.

First, take a look at the {\ttfamily random\+\_\+shuffle()} method in middleearth.\+cpp\+:


\begin{DoxyCode}
random\_shuffle(cities.begin(), cities.end());
\end{DoxyCode}


This method takes a vector, and will randomly shuffle it, similar to Java\textquotesingle{}s {\ttfamily Collections.\+shuffle()}. The parameters specify the amount of the vector that we want to shuffle. Because we want to shuffle the entire vector, we specify the beginning and end of the list, as shown. What we are actually doing is supplying two iterators which specify the range to shuffle. The {\ttfamily .begin()} and {\ttfamily .end()} methods provide iterators set to the beginning and end of the vector, respectively.

The {\ttfamily sort()} method has the same parameters as shuffle, and sorts the list. It is similar to Java\textquotesingle{}s {\ttfamily Collections.\+sort()} method. It returns no value.

The {\ttfamily next\+\_\+permutation()} method will cycle through each and every permutation of the passed vector. $\ast$$\ast$$\ast$\+It must start out with a sorted vector$\ast$$\ast$$\ast$, and will move through each and every possible list ordering until it the vector ends up in reverse sorted order. It takes the same parameters as {\ttfamily random\+\_\+shuffle()} and {\ttfamily sort()}. Note that it does not return a new permutation, but instead modifies the vector that is passed in (via the two iterators). It returns a bool -- {\ttfamily true} if it found another permutation, or {\ttfamily false} if there are no more permutations to provide. Thus, it is often put into a {\ttfamily while} loop. For an example of using {\ttfamily next\+\_\+permutation()} in a while loop, see \href{http://www.cplusplus.com/reference/algorithm/next_permutation/}{\tt here}. This is a good way to iterate through each possible combination of cities to travel to.

\subsubsection*{Middle-\/\+Earth methods}

The \hyperlink{class_middle_earth}{Middle\+Earth} class provides a number of methods to help you write your brute-\/force solution. You should be familiar with these from the pre-\/lab. The constructor is called by the skeleton code, and uses the parameters read in from the command line. The {\ttfamily print()} method will print out statistics of the world.

The {\ttfamily print\+Table()} method will print out a table of the distances between all cities. Different random seeds will produce different tables, obviously. This will be useful to help you debug your program. Redirect it to a file, and then load it up in a spreadsheet program (Excel may not like tab-\/separated values, but Open\+Office will be fine with it). We used to provide an Excel-\/ready format of this, but each of the different platforms (Mac OS X, Linux, Windows, as well as 32-\/bit versus 64-\/bit) will produce slightly different random worlds.

The {\ttfamily get\+Distance()} method will return the distance, as a float, between the two provided cities. In an effort to make your code as efficient as possible, {\ttfamily get\+Distance()} has the same running time as a hash table (usually {$\Theta$}(1)). Lastly, {\ttfamily get\+Itinerary()} will return a vector of the cities that you must visit. Note that the first city provided is the start (and thus end) city -- you should remove this from the vector before you consider all possible cycles through the graph.

\subsubsection*{How to proceed}

We provide the skeleton code for the algorithm -- your job is to complete traveling.\+cpp.


\begin{DoxyEnumerate}
\item First complete {\ttfamily print\+Route()}, as that will be useful when debugging your code. It should print a route in the form\+: {\ttfamily Dunharrow -\/$>$ Cirith Ungol -\/$>$ Hobbiton -\/$>$ Grey Havens -\/$>$ Lothlorien -\/$>$ Dunharrow}. Note that we aren\textquotesingle{}t picky about exactly how it\textquotesingle{}s printed, as long as it prints all the cities.
\item Next, complete {\ttfamily compute\+Distance()}. You can create a sample string vector to test it, and verify it against the distances in the output of {\ttfamily print\+Table()} (see above).
\item Start on the {\ttfamily main()} method. Make sure that you can print out all the permutations of the list of destinations. Note that for n cities, there are n! possible permutations. Remember that the start city should not be permuted!
\item At this point, you can now compute the distance and keep track of the minimum cycle length.
\end{DoxyEnumerate}

Your final program should not print out every path tried, as there will be way too many of them. It should print out the shortest path as the last thing printed. You may print out a few paths (i.\+e. successively shorter paths), if that\textquotesingle{}s easier.

Note that you are determining a cycle of cities to visit. So if your cycle has the cities in reverse, then it\textquotesingle{}s still a valid solution.

\subsubsection*{Getting your itinerary correct}

Note that you already know your start city (if you don\textquotesingle{}t know how to determine this, you should really read the comments in middleearth.\+cpp, specifically for {\ttfamily get\+Itinerary()}). This city is {\bfseries not to be permuted}, as you will always start (and end) at that city. It\textquotesingle{}s the {\itshape other} cities that are going to be permuted through the calls to {\ttfamily next\+\_\+permutation()}.

\subsubsection*{Timing your code}

Keep in mind that as you increase the size of the city tour, the running time increases exponentially. The computers in the Olsson 001 lab can probably compute about 200,000 routes per second in Linux (with well written and optimized code). Our 10-\/route cycle took 18 seconds under Linux. A 15 route cycle would take 2.\+5 months under Linux. A 20 route cycle would take 385,734 years under Linux! Realistically, you shouldn\textquotesingle{}t be trying anything with an itinerary greater than 9 or 10.

And when you are planning on testing long paths, you should really compile your code with the {\ttfamily -\/\+O2} compiler option. It can speed up the program by a factor of two.

To time your code, enter {\ttfamily time} before the command on the command-\/line. For example\+:


\begin{DoxyCode}
student@cassiopeia:~/labs/lab11$ time ./a.out 20 20 20 14 8
./a.out 20 20 20 14 8
Your journey will take you along the path Dunharrow -> Lothlorien -> Mirkwood -> The Grey Havens -> 
             Minas Tirith -> Weathertop -> Hobbiton -> Edoras -> Cirith Ungol -> Dunharrow
and will have length 53.9495

real    0m0.105s
user    0m0.076s
sys 0m0.020s
student@cassiopeia:~/labs/lab11$ 
\end{DoxyCode}


The time we are looking at is the \char`\"{}user\char`\"{} time; this is how long it took to run the user\textquotesingle{}s program. The \char`\"{}sys\char`\"{} line is how much time the system was doing things during the program execution, such as I/O. The \char`\"{}real\char`\"{} time is the \char`\"{}wall time\char`\"{} -- meaning if you had a stop watch, it would report the \char`\"{}real\char`\"{} time. The \char`\"{}real\char`\"{} time includes many other things, such as other tasks you are doing on the computer -- if you have an animation running in a web browser, for example, it will increase the \char`\"{}real\char`\"{} time, as the system is spending some effort rendering those animations. We\textquotesingle{}ll only use the \char`\"{}user\char`\"{} time for this lab. Note that you should {\bfseries N\+OT} print out every path -- you can print out some, as described above. But printing out every path will cause the computer to spend a lot of time on I/O, which will increase all of the times.

\subsubsection*{Sample output}

For this lab, we will keep the size of the 2-\/D world fixed at (20,20). These are the first two command line parameters. We\textquotesingle{}ll also create a world of 20 cities (chosen from the 40 names in middleearth.\+cpp) -- this is the third command line parameter.

If the random seed (the fourth parameter) is 14, then the path lengths and paths for the various itinerary lengths are listed below. Because we are explicitly setting the random seed, it should produce the exact same results each time -- and thus your code should also produce the same results.

{\bfseries Important note\+:} The method for determining the random seed is different on different systems. So using a random seed of 14 (which is what we used), you may get different results on different systems. We provide the Virtual Box results here, and other 32-\/bit and 64-\/bit Linux installations {\itshape should} be similar. But your results may differ! In particular, if you have a different flavor of Linux installed, use a Mac, etc. The machines in Olsson 001 have the same results as shown below. Also note that the direction of your path can be reversed -- it\textquotesingle{}s the same distance (and thus still the shortest path), even if the path order is reversed. You should use the output of your {\ttfamily print\+Table()} over what is listed below.

The Linux results for a random seed of 14, world size of 20x20 with 20 cities, and various path lengths\+:


\begin{DoxyEnumerate}
\item Minimum path has distance 16.\+4499\+: Dunharrow -\/$>$ The Grey Havens -\/$>$ Dunharrow
\item Minimum path has distance 38.\+5555\+: Dunharrow -\/$>$ Hobbiton -\/$>$ The Grey Havens -\/$>$ Dunharrow
\item Minimum path has distance 39.\+1172\+: Dunharrow -\/$>$ Cirith Ungol -\/$>$ Hobbiton -\/$>$ The Grey Havens -\/$>$ Dunharrow
\item Minimum path has distance 44.\+6487\+: Dunharrow -\/$>$ Cirith Ungol -\/$>$ Hobbiton -\/$>$ The Grey Havens -\/$>$ Lothlorien -\/$>$ Dunharrow
\item Minimum path has distance 51.\+7731\+: Dunharrow -\/$>$ Cirith Ungol -\/$>$ Hobbiton -\/$>$ Minas Tirith -\/$>$ The Grey Havens -\/$>$ Lothlorien -\/$>$ Dunharrow
\item Minimum path has distance 53.\+8414\+: Dunharrow -\/$>$ Cirith Ungol -\/$>$ Edoras -\/$>$ Hobbiton -\/$>$ Minas Tirith -\/$>$ The Grey Havens -\/$>$ Lothlorien -\/$>$ Dunharrow
\item Minimum path has distance 53.\+9410\+: Dunharrow -\/$>$ Cirith Ungol -\/$>$ Edoras -\/$>$ Hobbiton -\/$>$ Minas Tirith -\/$>$ The Grey Havens -\/$>$ Mirkwood -\/$>$ Lothlorien -\/$>$ Dunharrow
\item Minimum path has distance 53.\+9495\+: Dunharrow -\/$>$ Lothlorien -\/$>$ Mirkwood -\/$>$ The Grey Havens -\/$>$ Minas Tirith -\/$>$ Weathertop -\/$>$ Hobbiton -\/$>$ Edoras -\/$>$ Cirith Ungol -\/$>$ Dunharrow
\item Minimum path has distance 55.\+6973\+: Dunharrow -\/$>$ Edoras -\/$>$ Cirith Ungol -\/$>$ Dagorlad -\/$>$ Hobbiton -\/$>$ Weathertop -\/$>$ Minas Tirith -\/$>$ The Grey Havens -\/$>$ Mirkwood -\/$>$ Lothlorien -\/$>$ Dunharrow
\item Minimum path has distance 55.\+7040\+: Dunharrow -\/$>$ Lothlorien -\/$>$ Mirkwood -\/$>$ Orodruin -\/$>$ The Grey Havens -\/$>$ Minas Tirith -\/$>$ Weathertop -\/$>$ Hobbiton -\/$>$ Dagorlad -\/$>$ Cirith Ungol -\/$>$ Edoras -\/$>$ Dunharrow
\end{DoxyEnumerate}

Note that your cycle may be the same cities but in reverse; this is perfectly acceptable.

When compiled with {\ttfamily -\/\+O2}, the computation of a path of length 10 took 18 seconds on Linux.

Your final program needs to both be able to compile and run with the specified command-\/line parameters.

\subsubsection*{Makefile}

Your Makefile should have {\bfseries only one} target, which you can name anything you want. This target should do {\bfseries two} things\+: compile your code, and run doxygen. You can have two tabbed lines after the target specifier, which is the easiest way to accomplish this. In other words, we are just going to call {\ttfamily make}, and we want it to both compile your code and create your doxygen documentation. The in-\/lab Makefile should have the same dual-\/purpose target. 



\subsection*{Post-\/lab }

There are two parts to the post-\/lab\+: a complexity analysis of your code, as well as investigating acceleration techniques for the traveling salesperson problem.

The deliverable for the post-\/lab is a P\+DF document named postlab11.\+pdf. It must be in P\+DF format! See \href{../../docs/convert_to_pdf.html}{\tt How to convert a file to P\+DF} for details.

\subsubsection*{Complexity analysis}

For this part of the post-\/lab, we want you to do a time and space complexity analysis of both of your pre-\/lab code and your in-\/lab code. How long is your algorithm? In addition to a big-\/\+Theta notation, give an explanation as to why.

\subsubsection*{Acceleration techniques}

We all know that the solution for the traveling salesperson is inefficient. So inefficient that a 20 route tour through Middle Earth (i.\+e. using the command-\/line parameters {\ttfamily 20 20 20 14 20}) would take over 3 hundred thousand years when running on Linux, assuming the computer can check about 200,000 paths per second. We could run it on a more efficient computer -- this would help, but not much. If you are trying to compute a \href{https://www.google.com/search?q=61!}{\tt 61-\/route tour}, then there are more possibilities than there are \href{http://www.universetoday.com/36302/atoms-in-the-universe/}{\tt atoms in the known universe}. So it\textquotesingle{}s not likely that you will be able to push that many electrons through your computer, even if you could wait the \href{https://www.google.com/search?q=61!%2F(200000*60*60*24*365.25)}{\tt 10\textsuperscript{70}} years required. You might be able to lower that somewhat if you used a more efficient computer -- perhaps to 10\textsuperscript{69} years. That\textquotesingle{}s still longer than the expected life of the universe.

It\textquotesingle{}s safe to say that we can all agree that this problem is very inefficient. Yet the world record for the longest traveling salesperson solution is a whopping 85,900 cities! See the \href{http://en.wikipedia.org/wiki/Traveling_salesman_problem#Exact_algorithms}{\tt here} for details.

Let\textquotesingle{}s do a bit of math. If we assume that a properly coded solution runs in {$\Theta$}({\itshape n}!) time (yours may be different, by the way, but probably not by much), then this size input set would take 85960! steps. That\textquotesingle{}s 9.\+61 $\ast$ 10\textsuperscript{386,526} (yes, there are more than 1/3 of a million digits in this number). Let\textquotesingle{}s assume we could get a fast program to compute 1 million possible paths per second. With 60 seconds per minute, 60 minutes per hour, 24 hours per day, and 365.\+25 days per year, that will take 3.\+04 $\ast$ 10\textsuperscript{386,516} years (the exponent lowered by 10). With a number this big, a faster computer will not make much of a difference.

The people who computed the 85,900 city traveling salesperson problem obviously did not wait forever for it to compute. In fact, they managed to compute it in 136 C\+PU years! It took far less time to complete (say, 6 months or so), as it ran in parallel on multiple computers.

To accomplish this, they had to use a number of acceleration techniques.

The second part of the post-\/lab is for you to research other acceleration techniques that can be used to speed up the traveling salesperson problem. You are welcome to view the Wikipedia page -- however, we also know what\textquotesingle{}s on the Wikipedia page. So just copying that information down will get you no credit -- you need to understand the acceleration techniques, and write them in your {\itshape O\+WN} words. Basically, we want you to investigate and understand this, and not just paraphrase what Wikipedia says. We are going to read the Wikipedia page (and other similar pages) before we grade the post-\/lab.

Your report should include information on 3 such acceleration techniques (again, feel free to start with the 3 that Wikipedia mentions). You should write sufficient text on each to explain how it would work, the running time, and an estimate of how much faster it would make your code. You don\textquotesingle{}t need to implement any of these techniques -- just understand (at the high level) how they work.

You should discuss at least one approximation technique (ones that get a reasonable answer, but not necessarily an exact answer) and at least one exact acceleration technique. Your third one can be either. 